The Fn service API can be accessed within your cluster at:

 - http://{{template  "fullname" .}}-api.{{ .Release.Namespace }}:{{ .Values.fn.service.port}}

Set these environment variables to use the Fn service from outside the cluster:

{{- if contains "NodePort" .Values.fn.service.type }}

    export NODE_PORT=$(kubectl get --namespace {{ .Release.Namespace }} -o jsonpath="{.spec.ports[0].nodePort}" services {{ template "fullname" . }}-api)
    export NODE_IP=$(kubectl get nodes --namespace {{ .Release.Namespace }} -o jsonpath="{.items[0].status.addresses[0].address}")

    export FN_API_URL=http://$NODE_IP:$NODE_PORT

{{- if .Values.fnserver.splitWorkers }}
    export RUNNER_NODE_PORT=$(kubectl get --namespace {{ .Release.Namespace }} -o jsonpath="{.spec.ports[0].nodePort}" services {{ template "fullname" . }}-api)
    export FN_RUNNER_URL=http://$NODE_IP:$RUNNER_NODE_PORT

App/function routes are reachable under $FN_RUNNER_URL/r/

{{- end }}

{{- else if contains "LoadBalancer" .Values.fn.service.type }}

!! NOTE: It may take a few minutes for the API load balancer to become available.

You can watch for EXTERNAL-IP to populate by running:

  kubectl get svc --namespace {{ .Release.Namespace }} -w {{ template "fullname" . }}-api

Then set

    export FN_API_URL=http://$(kubectl get svc --namespace {{ .Release.Namespace }} {{ template "fullname" . }}-api -o jsonpath='{.status.loadBalancer.ingress[0].ip}'):{{ .Values.fn.service.port }}

{{- if .Values.fnserver.splitWorkers }}

Similarly, you can watch for the EXTERNAL-IP of the runner URL:

  kubectl get svc --namespace {{ .Release.Namespace }} -w {{ template "fullname" . }}-runner

Then set

    export FN_RUNNER_URL=http://$(kubectl get svc --namespace {{ .Release.Namespace }} {{ template "fullname" . }}-runner -o jsonpath='{.status.loadBalancer.ingress[0].ip}'):{{ .Values.fn.service.port }}

App/function routes are reachable under $FN_RUNNER_URL/r/

{{- end }}

{{- else if contains "ClusterIP" .Values.fn.service.type }}

    export POD_NAME=$(kubectl get pods --namespace {{ .Release.Namespace }} -l "app={{ template "fullname" . }},role=fn-service" -o jsonpath="{.items[0].metadata.name}")
    kubectl port-forward --namespace {{ .Release.Namespace }} $POD_NAME 8080:80 &
    export FN_API_URL=http://127.0.0.1:8080

{{- if .Values.fnserver.splitWorkers }}
    export RUNNER_POD_NAME=$(kubectl get pods --namespace {{ .Release.Namespace }} -l "app={{ template "fullname" . }},role=fn-runner" -o jsonpath="{.items[0].metadata.name}")
    kubectl port-forward --namespace {{ .Release.Namespace }} $POD_NAME 8081:80 &
    export FN_RUNNER_URL=http://127.0.0.1:8081

App/function routes are reachable under $FN_RUNNER_URL/r/

{{- end }}

{{- end }}

{{- if not  .Values.mysql.persistence.enabled }}

############################################################################
###   WARNING: Persistence is disabled!!! You will lose function and     ###
###   flow state when the MySQL pod is terminated.                       ###
###   See the README.md for instructions on configuring persistence.     ###
############################################################################
{{- end }}
